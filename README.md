# Курсова робота - консольний застосунок **"GeometryDash"**

_Виконав Ковальчук Вадим КП-42_

## Про застосунок

- `GeometryDash` — це консольна 2D-гра, де гравець керує кубом і його головна мета оминути усі перешкоди, щоб пройти рівень.
- керувати грою можна за допомогою клавіші `space` (стрибок).

## Механіки гри

- Гравець автоматично рухається вперед (імітація через прокрутку карти).
- Стрибок здійснюється натисканням `space`.
- Якщо гравець торкається перешкоди (`▲`), гра завершується. Також подбіно до оригінального "GeometryDash" треба розрахувати довжину стрибка і після стрибку опинитися на відстані щонайменше одного блоку після перешкоди. Інакше куб торкнувся б `▲`.
- Гравітація тягне гравця вниз, якщо під ним порожнеча.
- Перемога — досягти кінця карти (успішно пройти всі перешкоди).

## Основні технології

- **C# (.NET 8.0)**  
  Використовується сучасна версія платформи .NET 8.0, яка має високу продуктивність для створення консольних застосунків.

- **Console API**  
  Застосовується для взаємодії з користувачем:

  - вивід тексту,
  - зчитування натискань клавіш (`Console.ReadKey()`),
  - очищення екрану (`Console.Clear()`),
  - та інше

- **StringBuilder**  
  Використовується для формування кадру перед виводом у консоль.

- Також у проекті дотримувавася принципів ООП та вибудував якісну арітектуру.

## **Архітектура** проекту

```
Kursach/
├── GameCore/
│ ├── Game.cs
│ └── PlayerController.cs
├── GameEngine/
│ ├── MapLoader.cs
│ ├── MapRenderer.cs
│ └── WindowScroller.cs
├── Levels/
│ ├── BetaLevel.txt
│ └── FirstLevel.txt
├── Menu/
│ ├── EndMenu.cs
│ ├── LevelSelectionMenu.cs
│ └── StartMenu.cs
├── Models/
│ ├── Tile.cs
│ └── TileType.cs
├── Utils/
│ └── ConsoleHelper.cs
└── GameRunner.cs
```

## **Головне** про проект

- GameCore - відповідає за _технічну_ частину роботи гри
  - Game
    - містить основний ігровий цикл та обробку подій
  - PlayerController
    - містить в собі все пов'язане з рухом гравця
- GameEngine - відповідає за _правила та механіки_
  - MapLoader
    - зчитує рівень з **txt** файлу в двовимірний масив
    - :bulb: прийняте рішення використовувати двовимірний масив задля того щоб було зручно працювати з координатами карти (x, y)
  - MapRenderer
    - виводить карту в консоль
    - :bulb: використовується `StringBuilder` задля плавнішої анімації. Адже спочатку повністю створюється кадр і лише потім виводиться. Це зменшує мерехтіння та забезпечує плавну анімацію.
  - WindowScroller
    - MapView - рамка яка містить в собі певну частину основної карти
    - ScrollLeft - змінює видиму частину карти відображаючи в ній наступні елементи основної карти.
- Levels - містить різні _рівні гри_
  - :bulb: прийняте рішення зберігати карти саме в **txt** форматі
    - _гнучке_ керування картою
    - зручно змінювати карту, редагувати, створювати нові карти
- Menu
  - Містить в собі усі необхідні меню
- Models - містить _структури_ задля зчитування рівнів гри та об'єктів в них
  - Tile
    - Tile — це `record`, який представляє одну клітинку карти. Містить символ (**Symbol**) для відображення в консолі та тип (**TileType**), що визначає функціональну роль клітинки (перешкода, гравець, порожня тощо). Завдяки використанню `record`, структура є незмінною та зручною для роботи з колекціями.
  - TileType
    - TileType — це перелік `enum`, який визначає тип клітинки.
- Utils - містить в собі _допоміжний файл_
  - ConsoleHelper - очищує буфер перед зчитанням клавіші. Додано задля того щоб зчитувати клавішу можна було тільки після виводу тексту а не з початку виконання програми.
- GameRunner.cs
  - запускає гру

_:bulb: - позначені місця в яких коротко описано ключові технічні рішення_

## **Детальніше** про ключові файли `GameCore`

### Game.cs

- `class Game` в якому
  - реалізовані методи для відтворення гри та оброблення різних ігрових станів
  - використані необхідні методи з інших файлів, зокрема для анімації, зчитування карти, виводу карти, виводу меню та інше.

```
...
оголошуються об'єкти класів, щоб потім взаємодіяти їх з `методами`

public bool StartGame()
{
    Код реалізації
}
private bool IsSpacePressed()
{
    Код реалізації
}
private (int width, Tile[,] mapView) Jump(int width, Tile[,] mapView, Tile[,] fullMap)
{
    Код реалізації
}
private bool HandleWin(Tile[,] map)
{
    Код реалізації
}
private (bool repCondition, bool deathCondition) HandleLose()
{
    Код реалізації
}
private bool HasObstaclesAhead(Tile[,] map, int xPlayer)
{
    Код реалізації
}
```

- Детальніше про метод `StartGame()`, адже в ньому реалізована основна логіка

```
public bool StartGame()
{
    ...

    while (HasObstaclesAhead(mapView, x))
    {
        PrintMap(...);
        ...
        if (mapView[y, x + 1].Type == TileType.Spike || mapView[y, x - 1].Type == TileType.Spike)
        {
            ...HandleLose()
        }
        if (IsSpacePressed())
        {
            ...Jump(...)
        }
        ...ScrollLeft(...);
        Thread.Sleep(...);
    }
    if (!deathCondition)
    {
        ...HandleWin(...)
    }
    ...
}
```

- Перед основним циклом відбувається
  зчитування **карти**
  форматування до розміру **вікна**
  підготовка до основного циклу
- В тілі циклу
  - все відбувається поки після куба (гравця) є якісь перешкоди
  - перевірка умови програшу і її оброблення
  - обробка натиcкання **space**
- Якщо цикл успішно завершився оброблюється **перемога** і повертається значення відносно його відбувається закінчення/перезапуск гри
- Використання таких методів як `ScrollLeft`, `PrintMap`, `ThreadSleep` (бібліотека c# `System.Threading`), а також стрибок, кадри якого відтворюються завдяки методу `Jump` і дають в результаті анімацію.

### PlayerController.cs

- `class PlayerController` - в якому реалізовані методи необхідні для
  - стрибка гравця
  - знаходження координат гравця на карті

```
public Tile[,] MovePlayerUp(Tile[,] map)
{
    MovePlayer(...)
    ...
}
public Tile[,] MovePlayerDown(Tile[,] map, int height = 2)
{
    MovePlayer(...)
    ...
}

public (int X, int Y) FindPlayer(Tile[,] map)
{

    ...
}
private Tile[,] MovePlayer(Tile[,] map, int deltaY)
{
    ...FindPlayer(...)
    ...
}
```

# Висновок

_Курсова робота_ успішно виконана з досягненням усіх поставлених цілей. Розроблена гра повністю функціональна та готова до використання. Її архітектура дозволяє масштабувати проект в майбутньому.
